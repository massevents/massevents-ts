import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.object.freeze.js";

var _templateObject, _templateObject2;

import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.object.assign.js";
import "core-js/modules/es.promise.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.array.includes.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "regenerator-runtime/runtime.js";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import deprecate from 'util-deprecate';
import dedent from 'ts-dedent';
import Events, { IGNORED_EXCEPTION } from '@storybook/core-events';
import { logger } from '@storybook/client-logger';
import global from 'global';
import { addons } from '@storybook/addons';
import { StoryStore } from '@storybook/store';
import { UrlStore } from './UrlStore';
import { WebView } from './WebView';
import { StoryIndexClient } from './StoryIndexClient';
var globalWindow = global.window,
    AbortController = global.AbortController,
    FEATURES = global.FEATURES;

function focusInInput(event) {
  var target = event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;
}

function createController() {
  if (AbortController) return new AbortController(); // Polyfill for IE11

  return {
    signal: {
      aborted: false
    },
    abort: function abort() {
      this.signal.aborted = true;
    }
  };
}

var INVALIDATE = 'INVALIDATE';
export var PreviewWeb = /*#__PURE__*/function () {
  function PreviewWeb() {
    var _this = this;

    _classCallCheck(this, PreviewWeb);

    this.channel = void 0;
    this.urlStore = void 0;
    this.indexClient = void 0;
    this.storyStore = void 0;
    this.view = void 0;
    this.renderToDOM = void 0;
    this.previousSelection = void 0;
    this.previousStory = void 0;
    this.previousCleanup = void 0;
    this.channel = addons.getChannel();
    this.view = new WebView();
    this.urlStore = new UrlStore();
    this.storyStore = new StoryStore(); // Add deprecated APIs for back-compat
    // @ts-ignore

    this.storyStore.getSelection = deprecate(function () {
      return _this.urlStore.selection;
    }, dedent(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n        `__STORYBOOK_STORY_STORE__.getSelection()` is deprecated and will be removed in 7.0.\n  \n        To get the current selection, use the `useStoryContext()` hook from `@storybook/addons`.\n      "], ["\n        \\`__STORYBOOK_STORY_STORE__.getSelection()\\` is deprecated and will be removed in 7.0.\n  \n        To get the current selection, use the \\`useStoryContext()\\` hook from \\`@storybook/addons\\`.\n      "]))));
  }

  _createClass(PreviewWeb, [{
    key: "initialize",
    value: function initialize(_ref) {
      var _this2 = this;

      var getStoryIndex = _ref.getStoryIndex,
          importFn = _ref.importFn,
          getProjectAnnotations = _ref.getProjectAnnotations;
      this.storyStore.setProjectAnnotations(this.getProjectAnnotationsOrRenderError(getProjectAnnotations) || {});
      this.setupListeners();

      if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {
        this.indexClient = new StoryIndexClient();
        return this.indexClient.fetch().then(function (storyIndex) {
          _this2.storyStore.initialize({
            storyIndex: storyIndex,
            importFn: importFn,
            cache: false
          });

          return _this2.setGlobalsAndRenderSelection();
        }).catch(function (err) {
          logger.warn(err);

          _this2.renderPreviewEntryError(err);
        });
      }

      if (!getStoryIndex) {
        throw new Error('No `getStoryIndex` passed defined in v6 mode');
      }

      this.storyStore.initialize({
        storyIndex: getStoryIndex(),
        importFn: importFn,
        cache: true
      });
      this.channel.emit(Events.SET_STORIES, this.storyStore.getSetStoriesPayload());
      return this.setGlobalsAndRenderSelection();
    }
  }, {
    key: "getProjectAnnotationsOrRenderError",
    value: function getProjectAnnotationsOrRenderError(getProjectAnnotations) {
      var projectAnnotations;

      try {
        projectAnnotations = getProjectAnnotations();
        this.renderToDOM = projectAnnotations.renderToDOM;
        return projectAnnotations;
      } catch (err) {
        logger.warn(err); // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and
        // needs to be show to the user as a simple error

        this.renderPreviewEntryError(err);
        return undefined;
      }
    }
  }, {
    key: "setupListeners",
    value: function setupListeners() {
      globalWindow.onkeydown = this.onKeydown.bind(this);
      if (this.indexClient) this.indexClient.addEventListener(INVALIDATE, this.onStoryIndexChanged.bind(this));
      this.channel.on(Events.SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));
      this.channel.on(Events.UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));
      this.channel.on(Events.UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));
      this.channel.on(Events.RESET_STORY_ARGS, this.onResetArgs.bind(this));
    }
  }, {
    key: "setGlobalsAndRenderSelection",
    value: function () {
      var _setGlobalsAndRenderSelection = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _ref2, globals;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref2 = this.urlStore.selectionSpecifier || {}, globals = _ref2.globals;

                if (globals) {
                  this.storyStore.globals.updateFromPersisted(globals);
                }

                this.channel.emit(Events.SET_GLOBALS, {
                  globals: this.storyStore.globals.get() || {},
                  globalTypes: this.storyStore.projectAnnotations.globalTypes || {}
                });
                return _context.abrupt("return", this.selectSpecifiedStory());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setGlobalsAndRenderSelection() {
        return _setGlobalsAndRenderSelection.apply(this, arguments);
      }

      return setGlobalsAndRenderSelection;
    }() // Use the selection specifier to choose a story, then render it

  }, {
    key: "selectSpecifiedStory",
    value: function () {
      var _selectSpecifiedStory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this$urlStore$select, storySpecifier, viewMode, args, storyId;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.urlStore.selectionSpecifier) {
                  _context2.next = 4;
                  break;
                }

                _context2.next = 3;
                return this.renderMissingStory();

              case 3:
                return _context2.abrupt("return");

              case 4:
                _this$urlStore$select = this.urlStore.selectionSpecifier, storySpecifier = _this$urlStore$select.storySpecifier, viewMode = _this$urlStore$select.viewMode, args = _this$urlStore$select.args;
                storyId = this.storyStore.storyIndex.storyIdFromSpecifier(storySpecifier);

                if (storyId) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 9;
                return this.renderMissingStory(storySpecifier);

              case 9:
                return _context2.abrupt("return");

              case 10:
                this.urlStore.setSelection({
                  storyId: storyId,
                  viewMode: viewMode
                });
                this.channel.emit(Events.STORY_SPECIFIED, this.urlStore.selection);
                this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);
                _context2.next = 15;
                return this.renderSelection({
                  persistedArgs: args
                });

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function selectSpecifiedStory() {
        return _selectSpecifiedStory.apply(this, arguments);
      }

      return selectSpecifiedStory;
    }()
  }, {
    key: "onKeydown",
    value: function onKeydown(event) {
      if (!focusInInput(event)) {
        // We have to pick off the keys of the event that we need on the other side
        var altKey = event.altKey,
            ctrlKey = event.ctrlKey,
            metaKey = event.metaKey,
            shiftKey = event.shiftKey,
            key = event.key,
            code = event.code,
            keyCode = event.keyCode;
        this.channel.emit(Events.PREVIEW_KEYDOWN, {
          event: {
            altKey: altKey,
            ctrlKey: ctrlKey,
            metaKey: metaKey,
            shiftKey: shiftKey,
            key: key,
            code: code,
            keyCode: keyCode
          }
        });
      }
    }
  }, {
    key: "onSetCurrentStory",
    value: function onSetCurrentStory(selection) {
      this.urlStore.setSelection(selection);
      this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);
      this.renderSelection();
    }
  }, {
    key: "onUpdateGlobals",
    value: function onUpdateGlobals(_ref3) {
      var globals = _ref3.globals;
      this.storyStore.globals.update(globals);
      this.channel.emit(Events.GLOBALS_UPDATED, {
        globals: this.storyStore.globals.get(),
        initialGlobals: this.storyStore.globals.initialGlobals
      });
    }
  }, {
    key: "onUpdateArgs",
    value: function onUpdateArgs(_ref4) {
      var storyId = _ref4.storyId,
          updatedArgs = _ref4.updatedArgs;
      this.storyStore.args.update(storyId, updatedArgs);
      this.channel.emit(Events.STORY_ARGS_UPDATED, {
        storyId: storyId,
        args: this.storyStore.args.get(storyId)
      });
    }
  }, {
    key: "onResetArgs",
    value: function () {
      var _onResetArgs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref5) {
        var storyId, argNames, _ref6, initialArgs, argNamesToReset, updatedArgs;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                storyId = _ref5.storyId, argNames = _ref5.argNames;

                if (!(storyId === this.previousStory.id)) {
                  _context3.next = 5;
                  break;
                }

                _context3.t0 = this.previousStory;
                _context3.next = 8;
                break;

              case 5:
                _context3.next = 7;
                return this.storyStore.loadStory({
                  storyId: storyId
                });

              case 7:
                _context3.t0 = _context3.sent;

              case 8:
                _ref6 = _context3.t0;
                initialArgs = _ref6.initialArgs;
                argNamesToReset = argNames || Object.keys(this.storyStore.args.get(storyId));
                updatedArgs = argNamesToReset.reduce(function (acc, argName) {
                  acc[argName] = initialArgs[argName];
                  return acc;
                }, {});
                this.onUpdateArgs({
                  storyId: storyId,
                  updatedArgs: updatedArgs
                });

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function onResetArgs(_x) {
        return _onResetArgs.apply(this, arguments);
      }

      return onResetArgs;
    }()
  }, {
    key: "onStoryIndexChanged",
    value: function () {
      var _onStoryIndexChanged = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var storyIndex;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.indexClient.fetch();

              case 2:
                storyIndex = _context4.sent;
                return _context4.abrupt("return", this.onStoriesChanged({
                  storyIndex: storyIndex
                }));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function onStoryIndexChanged() {
        return _onStoryIndexChanged.apply(this, arguments);
      }

      return onStoryIndexChanged;
    }() // This happens when a glob gets HMR-ed

  }, {
    key: "onStoriesChanged",
    value: function () {
      var _onStoriesChanged = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref7) {
        var importFn, storyIndex;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                importFn = _ref7.importFn, storyIndex = _ref7.storyIndex;
                _context5.next = 3;
                return this.storyStore.onStoriesChanged({
                  importFn: importFn,
                  storyIndex: storyIndex
                });

              case 3:
                if (!this.urlStore.selection) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 6;
                return this.renderSelection();

              case 6:
                _context5.next = 10;
                break;

              case 8:
                _context5.next = 10;
                return this.selectSpecifiedStory();

              case 10:
                if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {
                  _context5.next = 17;
                  break;
                }

                _context5.t0 = this.channel;
                _context5.t1 = Events.SET_STORIES;
                _context5.next = 15;
                return this.storyStore.getSetStoriesPayload();

              case 15:
                _context5.t2 = _context5.sent;

                _context5.t0.emit.call(_context5.t0, _context5.t1, _context5.t2);

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function onStoriesChanged(_x2) {
        return _onStoriesChanged.apply(this, arguments);
      }

      return onStoriesChanged;
    }() // This happens when a config file gets reloade

  }, {
    key: "onGetProjectAnnotationsChanged",
    value: function onGetProjectAnnotationsChanged(_ref8) {
      var getProjectAnnotations = _ref8.getProjectAnnotations;
      var projectAnnotations = this.getProjectAnnotationsOrRenderError(getProjectAnnotations);

      if (!projectAnnotations) {
        return;
      }

      this.storyStore.setProjectAnnotations(projectAnnotations);
      this.renderSelection();
    } // We can either have:
    // - a story selected in "story" viewMode,
    //     in which case we render it to the root element, OR
    // - a story selected in "docs" viewMode,
    //     in which case we render the docsPage for that story

  }, {
    key: "renderSelection",
    value: function () {
      var _renderSelection = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this$previousSelecti, _this$previousSelecti2;

        var _ref9,
            persistedArgs,
            selection,
            story,
            storyIdChanged,
            viewModeChanged,
            implementationChanged,
            _this$storyStore$getS,
            parameters,
            initialArgs,
            argTypes,
            args,
            _args6 = arguments;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _ref9 = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {}, persistedArgs = _ref9.persistedArgs;

                if (this.urlStore.selection) {
                  _context6.next = 3;
                  break;
                }

                throw new Error('Cannot render story as no selection was made');

              case 3:
                selection = this.urlStore.selection;
                _context6.prev = 4;
                _context6.next = 7;
                return this.storyStore.loadStory({
                  storyId: selection.storyId
                });

              case 7:
                story = _context6.sent;
                _context6.next = 17;
                break;

              case 10:
                _context6.prev = 10;
                _context6.t0 = _context6["catch"](4);
                this.previousStory = null;
                logger.warn(_context6.t0);
                _context6.next = 16;
                return this.renderMissingStory(selection.storyId);

              case 16:
                return _context6.abrupt("return");

              case 17:
                storyIdChanged = ((_this$previousSelecti = this.previousSelection) === null || _this$previousSelecti === void 0 ? void 0 : _this$previousSelecti.storyId) !== selection.storyId;
                viewModeChanged = ((_this$previousSelecti2 = this.previousSelection) === null || _this$previousSelecti2 === void 0 ? void 0 : _this$previousSelecti2.viewMode) !== selection.viewMode;
                implementationChanged = !storyIdChanged && this.previousStory && story !== this.previousStory;

                if (persistedArgs) {
                  this.storyStore.args.updateFromPersisted(story, persistedArgs);
                } else if (implementationChanged) {
                  this.storyStore.args.resetOnImplementationChange(story, this.previousStory);
                } // Don't re-render the story if nothing has changed to justify it


                if (!(this.previousStory && !storyIdChanged && !implementationChanged && !viewModeChanged)) {
                  _context6.next = 24;
                  break;
                }

                this.channel.emit(Events.STORY_UNCHANGED, selection.storyId);
                return _context6.abrupt("return");

              case 24:
                _context6.next = 26;
                return this.cleanupPreviousRender({
                  unmountDocs: viewModeChanged
                });

              case 26:
                // If we are rendering something new (as opposed to re-rendering the same or first story), emit
                if (this.previousSelection && (storyIdChanged || viewModeChanged)) {
                  this.channel.emit(Events.STORY_CHANGED, selection.storyId);
                } // Record the previous selection *before* awaiting the rendering, in cases things change before it is done.


                this.previousSelection = selection;
                this.previousStory = story;
                _this$storyStore$getS = this.storyStore.getStoryContext(story), parameters = _this$storyStore$getS.parameters, initialArgs = _this$storyStore$getS.initialArgs, argTypes = _this$storyStore$getS.argTypes, args = _this$storyStore$getS.args;

                if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {
                  this.channel.emit(Events.STORY_PREPARED, {
                    id: story.id,
                    parameters: parameters,
                    initialArgs: initialArgs,
                    argTypes: argTypes,
                    args: args
                  });
                }

                if (!(selection.viewMode === 'docs' || story.parameters.docsOnly)) {
                  _context6.next = 37;
                  break;
                }

                _context6.next = 34;
                return this.renderDocs({
                  story: story
                });

              case 34:
                this.previousCleanup = _context6.sent;
                _context6.next = 38;
                break;

              case 37:
                this.previousCleanup = this.renderStory({
                  story: story
                });

              case 38:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[4, 10]]);
      }));

      function renderSelection() {
        return _renderSelection.apply(this, arguments);
      }

      return renderSelection;
    }()
  }, {
    key: "renderDocs",
    value: function () {
      var _renderDocs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref10) {
        var _this3 = this,
            _global$FEATURES;

        var story, id, title, name, element, csfFile, docsContext, render;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                story = _ref10.story;
                id = story.id, title = story.title, name = story.name;
                element = this.view.prepareForDocs();
                _context9.next = 5;
                return this.storyStore.loadCSFFileByStoryId(id, {
                  sync: false
                });

              case 5:
                csfFile = _context9.sent;
                docsContext = {
                  id: id,
                  title: title,
                  name: name,
                  // NOTE: these two functions are *sync* so cannot access stories from other CSF files
                  storyById: function storyById(storyId) {
                    return _this3.storyStore.storyFromCSFFile({
                      storyId: storyId,
                      csfFile: csfFile
                    });
                  },
                  componentStories: function componentStories() {
                    return _this3.storyStore.componentStoriesFromCSFFile({
                      csfFile: csfFile
                    });
                  },
                  loadStory: function loadStory(storyId) {
                    return _this3.storyStore.loadStory({
                      storyId: storyId
                    });
                  },
                  renderStoryToElement: this.renderStoryToElement.bind(this),
                  getStoryContext: function getStoryContext(renderedStory) {
                    return Object.assign({}, _this3.storyStore.getStoryContext(renderedStory), {
                      viewMode: 'docs'
                    });
                  }
                };

                render = /*#__PURE__*/function () {
                  var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                    var fullDocsContext;
                    return regeneratorRuntime.wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            fullDocsContext = Object.assign({}, docsContext, !(FEATURES !== null && FEATURES !== void 0 && FEATURES.breakingChangesV7) && _this3.storyStore.getStoryContext(story));
                            _context7.next = 3;
                            return import('./renderDocs');

                          case 3:
                            _context7.sent.renderDocs(story, fullDocsContext, element, function () {
                              return _this3.channel.emit(Events.DOCS_RENDERED, id);
                            });

                          case 4:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7);
                  }));

                  return function render() {
                    return _ref11.apply(this, arguments);
                  };
                }(); // Initially render right away


                render(); // Listen to events and re-render
                // NOTE: we aren't checking to see the story args are targetted at the "right" story.
                // This is because we may render >1 story on the page and there is no easy way to keep track
                // of which ones were rendered by the docs page.
                // However, in `modernInlineRender`, the individual stories track their own events as they
                // each call `renderStoryToElement` below.

                if (!(global !== null && global !== void 0 && (_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.modernInlineRender)) {
                  this.channel.on(Events.UPDATE_GLOBALS, render);
                  this.channel.on(Events.UPDATE_STORY_ARGS, render);
                  this.channel.on(Events.RESET_STORY_ARGS, render);
                }

                return _context9.abrupt("return", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
                  var _global$FEATURES2;

                  return regeneratorRuntime.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          if (!(global !== null && global !== void 0 && (_global$FEATURES2 = global.FEATURES) !== null && _global$FEATURES2 !== void 0 && _global$FEATURES2.modernInlineRender)) {
                            _this3.channel.off(Events.UPDATE_GLOBALS, render);

                            _this3.channel.off(Events.UPDATE_STORY_ARGS, render);

                            _this3.channel.off(Events.RESET_STORY_ARGS, render);
                          }

                        case 1:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8);
                })));

              case 11:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function renderDocs(_x3) {
        return _renderDocs.apply(this, arguments);
      }

      return renderDocs;
    }()
  }, {
    key: "renderStory",
    value: function renderStory(_ref13) {
      var _this4 = this;

      var story = _ref13.story;
      var element = this.view.prepareForStory(story);
      var id = story.id,
          componentId = story.componentId,
          title = story.title,
          name = story.name;
      var renderContext = {
        componentId: componentId,
        title: title,
        kind: title,
        id: id,
        name: name,
        story: name,
        showMain: function showMain() {
          return _this4.view.showMain();
        },
        showError: function showError(err) {
          return _this4.renderError(id, err);
        },
        showException: function showException(err) {
          return _this4.renderException(id, err);
        }
      };
      return this.renderStoryToElement({
        story: story,
        renderContext: renderContext,
        element: element
      });
    } // Render a story into a given element and watch for the events that would trigger us
    // to re-render it (plus deal sensibly with things like changing story mid-way through).

  }, {
    key: "renderStoryToElement",
    value: function renderStoryToElement(_ref14) {
      var _this5 = this;

      var story = _ref14.story,
          renderContextWithoutStoryContext = _ref14.renderContext,
          element = _ref14.element;
      var id = story.id,
          applyLoaders = story.applyLoaders,
          unboundStoryFn = story.unboundStoryFn,
          playFunction = story.playFunction;
      var phase;

      var isPending = function isPending() {
        return ['rendering', 'playing'].includes(phase);
      };

      var controller;
      var loadedContext;

      var render = /*#__PURE__*/function () {
        var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
          var _ref16,
              _ref16$initial,
              initial,
              _ref16$forceRemount,
              forceRemount,
              ctrl,
              runPhase,
              storyContext,
              renderStoryContext,
              renderContext,
              _args12 = arguments;

          return regeneratorRuntime.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  _ref16 = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {}, _ref16$initial = _ref16.initial, initial = _ref16$initial === void 0 ? false : _ref16$initial, _ref16$forceRemount = _ref16.forceRemount, forceRemount = _ref16$forceRemount === void 0 ? false : _ref16$forceRemount;
                  ctrl = controller; // we also need a stable reference within this closure

                  if (initial || forceRemount) {
                    // Abort the signal used by the previous render, so it'll (hopefully) stop executing. The
                    // play function might continue execution regardless, which we deal with during cleanup.
                    // Note we can't reload the page here because there's a legitimate use case for forceRemount
                    // while in the 'playing' phase: the play function may never resolve during debugging, while
                    // "step back" will trigger a forceRemount. In this case it's up to the debugger to reload.
                    if (ctrl) ctrl.abort();
                    ctrl = createController();
                    controller = ctrl;
                  }

                  runPhase = /*#__PURE__*/function () {
                    var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(phaseName, phaseFn) {
                      return regeneratorRuntime.wrap(function _callee10$(_context10) {
                        while (1) {
                          switch (_context10.prev = _context10.next) {
                            case 0:
                              phase = phaseName;

                              _this5.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {
                                newPhase: phase,
                                storyId: id
                              });

                              _context10.next = 4;
                              return phaseFn();

                            case 4:
                              if (ctrl.signal.aborted) {
                                phase = 'aborted';

                                _this5.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {
                                  newPhase: phase,
                                  storyId: id
                                });
                              }

                            case 5:
                            case "end":
                              return _context10.stop();
                          }
                        }
                      }, _callee10);
                    }));

                    return function runPhase(_x4, _x5) {
                      return _ref17.apply(this, arguments);
                    };
                  }();

                  if (!initial) {
                    _context12.next = 19;
                    break;
                  }

                  storyContext = _this5.storyStore.getStoryContext(story);
                  _context12.prev = 6;
                  _context12.next = 9;
                  return runPhase('loading', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
                    return regeneratorRuntime.wrap(function _callee11$(_context11) {
                      while (1) {
                        switch (_context11.prev = _context11.next) {
                          case 0:
                            _context11.next = 2;
                            return applyLoaders(Object.assign({}, storyContext, {
                              viewMode: element === _this5.view.storyRoot() ? 'story' : 'docs'
                            }));

                          case 2:
                            loadedContext = _context11.sent;

                          case 3:
                          case "end":
                            return _context11.stop();
                        }
                      }
                    }, _callee11);
                  })));

                case 9:
                  if (!ctrl.signal.aborted) {
                    _context12.next = 11;
                    break;
                  }

                  return _context12.abrupt("return");

                case 11:
                  _context12.next = 17;
                  break;

                case 13:
                  _context12.prev = 13;
                  _context12.t0 = _context12["catch"](6);
                  renderContextWithoutStoryContext.showException(_context12.t0);
                  return _context12.abrupt("return");

                case 17:
                  _context12.next = 21;
                  break;

                case 19:
                  if (loadedContext) {
                    _context12.next = 21;
                    break;
                  }

                  return _context12.abrupt("return");

                case 21:
                  // By this stage, it is possible that new args/globals have been received for this story
                  // and we need to ensure we render it with the new values
                  renderStoryContext = Object.assign({}, loadedContext, _this5.storyStore.getStoryContext(story), {
                    abortSignal: ctrl.signal,
                    canvasElement: element
                  });
                  renderContext = Object.assign({}, renderContextWithoutStoryContext, {
                    forceRemount: forceRemount,
                    storyContext: renderStoryContext,
                    storyFn: function storyFn() {
                      return unboundStoryFn(renderStoryContext);
                    },
                    unboundStoryFn: unboundStoryFn
                  });
                  _context12.prev = 23;

                  if (_this5.renderToDOM) {
                    _context12.next = 26;
                    break;
                  }

                  throw new Error(dedent(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n            Expected 'framework' in your main.js to export 'renderToDOM', but none found.\n\n            You can fix this automatically by running:\n\n            npx sb@next automigrate\n        \n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field          \n          "]))));

                case 26:
                  _context12.next = 28;
                  return runPhase('rendering', function () {
                    return _this5.renderToDOM(renderContext, element);
                  });

                case 28:
                  if (!ctrl.signal.aborted) {
                    _context12.next = 30;
                    break;
                  }

                  return _context12.abrupt("return");

                case 30:
                  if (!(forceRemount && playFunction)) {
                    _context12.next = 35;
                    break;
                  }

                  _context12.next = 33;
                  return runPhase('playing', function () {
                    return playFunction(renderContext.storyContext);
                  });

                case 33:
                  if (!ctrl.signal.aborted) {
                    _context12.next = 35;
                    break;
                  }

                  return _context12.abrupt("return");

                case 35:
                  _context12.next = 37;
                  return runPhase('completed', function () {
                    return _this5.channel.emit(Events.STORY_RENDERED, id);
                  });

                case 37:
                  _context12.next = 42;
                  break;

                case 39:
                  _context12.prev = 39;
                  _context12.t1 = _context12["catch"](23);
                  renderContextWithoutStoryContext.showException(_context12.t1);

                case 42:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, null, [[6, 13], [23, 39]]);
        }));

        return function render() {
          return _ref15.apply(this, arguments);
        };
      }(); // Start the first (initial) render. We don't await here because we need to return the "cleanup"
      // function below right away, so if the user changes story during the first render we can cancel
      // it without having to first wait for it to finish.
      // Whenever the selection changes we want to force the component to be remounted.


      render({
        initial: true,
        forceRemount: true
      });

      var remountStoryIfMatches = function remountStoryIfMatches(_ref19) {
        var storyId = _ref19.storyId;
        if (storyId === story.id) render({
          forceRemount: true
        });
      };

      var rerenderStoryIfMatches = function rerenderStoryIfMatches(_ref20) {
        var storyId = _ref20.storyId;
        if (storyId === story.id) render();
      }; // Listen to events and re-render story
      // Don't forget to unsubscribe on cleanup


      this.channel.on(Events.UPDATE_GLOBALS, render);
      this.channel.on(Events.FORCE_RE_RENDER, render);
      this.channel.on(Events.FORCE_REMOUNT, remountStoryIfMatches);
      this.channel.on(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);
      this.channel.on(Events.RESET_STORY_ARGS, rerenderStoryIfMatches); // Cleanup / teardown function invoked on next render (via `cleanupPreviousRender`)

      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                // If the story is torn down (either a new story is rendered or the docs page removes it)
                // we need to consider the fact that the initial render may not be finished
                // (possibly the loaders or the play function are still running). We use the controller
                // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
                // happens inside the user's code.
                controller.abort();

                _this5.storyStore.cleanupStory(story);

                _this5.channel.off(Events.UPDATE_GLOBALS, render);

                _this5.channel.off(Events.FORCE_RE_RENDER, render);

                _this5.channel.off(Events.FORCE_REMOUNT, remountStoryIfMatches);

                _this5.channel.off(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);

                _this5.channel.off(Events.RESET_STORY_ARGS, rerenderStoryIfMatches); // Check if we're done rendering/playing. If not, we may have to reload the page.


                if (isPending()) {
                  _context13.next = 9;
                  break;
                }

                return _context13.abrupt("return");

              case 9:
                _context13.next = 11;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 0);
                });

              case 11:
                if (isPending()) {
                  _context13.next = 13;
                  break;
                }

                return _context13.abrupt("return");

              case 13:
                _context13.next = 15;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 0);
                });

              case 15:
                if (isPending()) {
                  _context13.next = 17;
                  break;
                }

                return _context13.abrupt("return");

              case 17:
                _context13.next = 19;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 0);
                });

              case 19:
                if (isPending()) {
                  _context13.next = 21;
                  break;
                }

                return _context13.abrupt("return");

              case 21:
                // If we still haven't completed, reload the page (iframe) to ensure we have a clean slate
                // for the next render. Since the reload can take a brief moment to happen, we want to stop
                // further rendering by awaiting a never-resolving promise (which is destroyed on reload).
                global.window.location.reload();
                _context13.next = 24;
                return new Promise(function () {});

              case 24:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }));
    }
  }, {
    key: "cleanupPreviousRender",
    value: function () {
      var _cleanupPreviousRender = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
        var _this$previousStory, _this$previousStory$p, _this$previousSelecti3;

        var _ref22,
            _ref22$unmountDocs,
            unmountDocs,
            previousViewMode,
            _args14 = arguments;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _ref22 = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : {}, _ref22$unmountDocs = _ref22.unmountDocs, unmountDocs = _ref22$unmountDocs === void 0 ? true : _ref22$unmountDocs;
                previousViewMode = (_this$previousStory = this.previousStory) !== null && _this$previousStory !== void 0 && (_this$previousStory$p = _this$previousStory.parameters) !== null && _this$previousStory$p !== void 0 && _this$previousStory$p.docsOnly ? 'docs' : (_this$previousSelecti3 = this.previousSelection) === null || _this$previousSelecti3 === void 0 ? void 0 : _this$previousSelecti3.viewMode;

                if (!(unmountDocs && previousViewMode === 'docs')) {
                  _context14.next = 6;
                  break;
                }

                _context14.next = 5;
                return import('./renderDocs');

              case 5:
                _context14.sent.unmountDocs(this.view.docsRoot());

              case 6:
                if (!this.previousCleanup) {
                  _context14.next = 9;
                  break;
                }

                _context14.next = 9;
                return this.previousCleanup();

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function cleanupPreviousRender() {
        return _cleanupPreviousRender.apply(this, arguments);
      }

      return cleanupPreviousRender;
    }()
  }, {
    key: "renderPreviewEntryError",
    value: function renderPreviewEntryError(err) {
      this.view.showErrorDisplay(err);
      this.channel.emit(Events.CONFIG_ERROR, err);
    }
  }, {
    key: "renderMissingStory",
    value: function () {
      var _renderMissingStory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(storySpecifier) {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.cleanupPreviousRender();

              case 2:
                this.view.showNoPreview();
                this.channel.emit(Events.STORY_MISSING, storySpecifier);

              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function renderMissingStory(_x6) {
        return _renderMissingStory.apply(this, arguments);
      }

      return renderMissingStory;
    }() // renderException is used if we fail to render the story and it is uncaught by the app layer

  }, {
    key: "renderException",
    value: function renderException(storyId, error) {
      this.channel.emit(Events.STORY_THREW_EXCEPTION, error);
      this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {
        newPhase: 'errored',
        storyId: storyId
      }); // Ignored exceptions exist for control flow purposes, and are typically handled elsewhere.

      if (error !== IGNORED_EXCEPTION) {
        this.view.showErrorDisplay(error);
        logger.error(error);
      }
    } // renderError is used by the various app layers to inform the user they have done something
    // wrong -- for instance returned the wrong thing from a story

  }, {
    key: "renderError",
    value: function renderError(storyId, _ref23) {
      var title = _ref23.title,
          description = _ref23.description;
      this.channel.emit(Events.STORY_ERRORED, {
        title: title,
        description: description
      });
      this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {
        newPhase: 'errored',
        storyId: storyId
      });
      this.view.showErrorDisplay({
        message: title,
        stack: description
      });
    }
  }]);

  return PreviewWeb;
}();