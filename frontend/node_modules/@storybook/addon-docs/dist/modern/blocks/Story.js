import React, { useContext, useRef, useEffect } from 'react';
import { MDXProvider } from '@mdx-js/react';
import global from 'global';
import { resetComponents, Story as PureStory } from '@storybook/components';
import { toId, storyNameFromExport } from '@storybook/csf';
import { addons } from '@storybook/addons';
import Events from '@storybook/core-events';
import { CURRENT_SELECTION } from './types';
import { DocsContext } from './DocsContext';
import { useStory } from './useStory';
export const storyBlockIdFromId = storyId => `story--${storyId}`;
export const lookupStoryId = (storyName, {
  mdxStoryNameToKey,
  mdxComponentAnnotations
}) => toId(mdxComponentAnnotations.id || mdxComponentAnnotations.title, storyNameFromExport(mdxStoryNameToKey[storyName]));
export const getStoryId = (props, context) => {
  const {
    id
  } = props;
  const {
    name
  } = props;
  const inputId = id === CURRENT_SELECTION ? context.id : id;
  return inputId || lookupStoryId(name, context);
};
export const getStoryProps = ({
  height,
  inline
}, story, context, onStoryFnCalled) => {
  const {
    name: storyName,
    parameters
  } = story;
  const {
    docs = {}
  } = parameters;

  if (docs.disable) {
    return null;
  } // prefer block props, then story parameters defined by the framework-specific settings and optionally overridden by users


  const {
    inlineStories = false,
    iframeHeight = 100,
    prepareForInline
  } = docs;
  const storyIsInline = typeof inline === 'boolean' ? inline : inlineStories;

  if (storyIsInline && !prepareForInline) {
    throw new Error(`Story '${storyName}' is set to render inline, but no 'prepareForInline' function is implemented in your docs configuration!`);
  }

  const boundStoryFn = () => {
    const storyResult = story.unboundStoryFn(Object.assign({}, context.getStoryContext(story), {
      loaded: {},
      abortSignal: undefined,
      canvasElement: undefined
    })); // We need to wait until the bound story function has actually been called before we
    // consider the story rendered. Certain frameworks (i.e. angular) don't actually render
    // the component in the very first react render cycle, and so we can't just wait until the
    // `PureStory` component has been rendered to consider the underlying story "rendered".

    onStoryFnCalled();
    return storyResult;
  };

  return Object.assign({
    inline: storyIsInline,
    id: story.id,
    height: height || (storyIsInline ? undefined : iframeHeight),
    title: storyName
  }, storyIsInline && {
    parameters,
    storyFn: () => prepareForInline(boundStoryFn, context.getStoryContext(story))
  });
};

const Story = props => {
  var _global$FEATURES;

  const context = useContext(DocsContext);
  const channel = addons.getChannel();
  const ref = useRef();
  const storyId = getStoryId(props, context);
  const story = useStory(storyId, context);
  useEffect(() => {
    let cleanup;

    if (story && ref.current) {
      const {
        componentId,
        id,
        title,
        name
      } = story;
      const renderContext = {
        componentId,
        title,
        kind: title,
        id,
        name,
        story: name,
        // TODO what to do when these fail?
        showMain: () => {},
        showError: () => {},
        showException: () => {}
      };
      cleanup = context.renderStoryToElement({
        story,
        renderContext,
        element: ref.current
      });
    }

    return () => cleanup && cleanup();
  }, [story]);

  if (!story) {
    return /*#__PURE__*/React.createElement("div", null, "Loading...");
  } // If we are rendering a old-style inline Story via `PureStory` below, we want to emit
  // the `STORY_RENDERED` event when it renders. The modern mode below calls out to
  // `Preview.renderStoryToDom()` which itself emits the event.


  const storyProps = getStoryProps(props, story, context, () => channel.emit(Events.STORY_RENDERED, storyId));

  if (!storyProps) {
    return null;
  }

  if (global !== null && global !== void 0 && (_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.modernInlineRender) {
    // We do this so React doesn't complain when we replace the span in a secondary render
    const htmlContents = `<span data-is-loading-indicator="true">loading story...</span>`; // FIXME: height/style/etc. lifted from PureStory

    const {
      height
    } = storyProps;
    return /*#__PURE__*/React.createElement("div", {
      id: storyBlockIdFromId(story.id)
    }, /*#__PURE__*/React.createElement(MDXProvider, {
      components: resetComponents
    }, height ? /*#__PURE__*/React.createElement("style", null, `#story--${story.id} { min-height: ${height}; transform: translateZ(0); overflow: auto }`) : null, /*#__PURE__*/React.createElement("div", {
      ref: ref,
      "data-name": story.name,
      dangerouslySetInnerHTML: {
        __html: htmlContents
      }
    })));
  }

  return /*#__PURE__*/React.createElement("div", {
    id: storyBlockIdFromId(story.id)
  }, /*#__PURE__*/React.createElement(MDXProvider, {
    components: resetComponents
  }, /*#__PURE__*/React.createElement(PureStory, storyProps)));
};

Story.defaultProps = {
  children: null,
  name: null
};
export { Story };